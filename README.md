# puzzle_meow
C++大作业，喵之拼图

## 运行环境
* 处理图片用了opencv的包，可执行文件必须和相应的ddl文件在同一目录之下。
* 在windows10下编写的所有代码，在win10下运行测试正常

## 运行流程
1. 安装运行环境
* 先在本地装好opencv的环境，这里只有这个项目的源码，装环境这里不赘述
* 这里给出了最后生成的windows可执行文件，里面有一个opencv的dll文件，二者必须在同一目录之下才可以
2. 输入图片地址
* 不同操作系统地址会有点不同，开发整个是在windows下进行的，mac和linux没有测试过。
* 项目中有一张作为默认狗粮
3. 输入拼图规模
* 拼图被划分成 N * M ，这里要输入 N 和 M
* 3阶的时候已经出现明显卡顿了，阶数太高肯定是不行的，毕竟核心算法的复杂度是n!
4. 随机打乱图片块
* 有一半的概率可以生成能完整复原的图片
* 当生成了不能复原的打乱图片，控制台会给出提示
* q表示退出，其他按键都可以执行下去
* 当生成了可以完整复原的图片时，就正式进入游戏
5. 游戏时，已经给出了详细的规则，这里给出一张截图
![游戏规则](./游戏规则.png "rule")
  
  注意：
* 除了上述规则中所提到的输入，其他输入都会被认为非法输入，会把规则重新打印出来，重新输入，包括一般可以退出程序的快捷键（ctrl +C  Alt +F4)需要程序退出可以根据规则退出
* 主界面下所有的输入不需要敲击回车就可以直接执行了，游戏体验更好

## 项目文件结构
- 头文件
-- Img.h ：定义 Img 类，主要用于一些图片的处理
-- Puzzle.h ： 定义了 Puzzle 类，是拼图的核心类，里面包括拼图游戏的核心操作 
-- util.h ： 定义一些辅助函数的声明和辅助内联函数的实现
- 源文件
-- main.cpp ： 程序的入口
-- Img.cpp ： Img 类成员函数的实现
-- Puzzle.cpp ： Puzzle 类成员函数的实现
-- util.cpp ： 辅助函数的实现

## 核心类和核心函数
- Img类
  - 图片分割是从像素级出发的，根据开始输入的划分规模，把分割下的多个小图片放到分割目录下
  - 图片拼接是先把一行所有的小图拼接成一条长图，各条长图再拼接出最后的图片
  - 由于我给出的默认图片比较大，在读取图片的时候是缩小为原来的1/3
``` C++
class Img
{
public:
	Img(string imgPath);
	~Img();
	void setsegPath(string str); // 设置分割目录
	void setsplicePath(string str); // 设置拼接目录
	void segment();  //图片分割
	void splice(vector<int> arr,string name, string outPath=" "); //图片拼接
	int readImg(string name,string imgPath =" "); //读取图片
private:
	string path;
	string segPath;   //分割目录
	string splicePath ;//拼接目录
};
```

  
- Puzzle类
  1. 移动： 先去找-1所在的位置，而后根据移动的方向找另一个图片块，如果已经在边界上了 则保持不动
  2. 重新游戏： 每次随机打乱图片块的位置时，都把打乱后的顺序记录下来，在重新游戏的时候就把对应数据读取出来
  3. 保存图像: 把当前状态下的图片保存到一个特定的位置上去，选择这种操作要输入保存的名称和保持路径
  4. 存档： 构造一个键值对，用名称未作键，相应的状态数据作为值，存储下来
  5. 读档： 根据输入的状态名称，读取对应的存档数据
  6. 检查是否完成： 在构造函数中就存储下完成的状态，打乱之后的状态不能和完成状态相同，每次移动都判断是否完成
  7. 判断是否可行： 用vector逆序对+空格所处位置的横纵坐标的值的奇偶性，来判断这个拼图是否可解。和ok下、奇偶相同就表示可解
  8. **自动还原**： 主要的算法，下文详述
  9. **图片预览**： 扩展功能，保存图片操作比较麻烦，且不好想象对应的图片是否是自己想要的，通过预览先看一下效果方便使用
``` C++
class Puzzle
{
public:
	INTVEC arr;
	Puzzle(INTVEC num);
	~Puzzle();
	bool available(); //判断拼图是否有解
	void puzzleMove(char t);  //拼图移动
	void showMat(INTVEC num = {}); //用数字展示现在的状态
	void shuffleShow();  //打乱图片块的位置
	void restart(); //重新开始游戏
	void saveImg(Img img); //把当前状态保存为图片
	void save();  //存档
	void load();  //读档
	void reduction(); //自动还原
	bool check(); //检查是否已经完成
	void showPossible(); //展示已经找到的可行方案
	void getAll(); //广度优先搜索所有的可行方案，在3*3以上都不适合用这种方法，耗时太久了
	void preview(Img img); //预览现在状态的图片，进入决定是否要把图片存储下来
private:
	int flag;//ok的逆序对加上-1的位置
	INTVEC ok; //记录完成的状态
	INTVEC init;//用于保存最初状态，用于重新开始
	map<string, INTVEC> states; //记录状态，用于存档和读档
	int getInv(INTVEC num = {});//获得数组的逆序对
	map<INTVEC, string> possible;//第一项是可行方案，第二项是到达路径
	INTVEC getSolution(map<INTVEC, string> &solution); // 双向广度优先搜索，找到相交的那个状态
	void initq2(queue <INTVEC>&q); //通过已经搜索的可行状态初始化队列
	void updatePossible(queue <INTVEC>&q); // 通过队列顶部的值，更新可行解的区域，以此优化查找
	/*
	用字符串路径定义
	""：完成
	W：上
	S：下
	A：左
	D：右
	*/
};
```

## 自动还原
1. 初步尝试：
  - 在判断可解性的时候就用广度优先搜索找到所有的可行解，并记录下所有可行解的还原方式
  - 之后只需要查找红黑书就可以知道对应的解
  - 优点：实现简单，把两个特性一次解决，而且后面查找的速度极快
  - 但实践证明，到3阶以上，搜索的速度非常之慢，毕竟是n!的复杂度，9！=362880，确定是否可解的时间不可忍受
2. 双向广度优先搜索
  - 判断是否可解用开始所说的方法，只要常数时间就可以做到，在寻找可行路径的时候用了双向广度优先搜索
  - 优点1： 可以不断记录下找到的可行解，理论上可以越搜越快
  - 优点2： 可以找到最短的实现路径
  - 缺点： 搜索速度不如深度优先搜索快
